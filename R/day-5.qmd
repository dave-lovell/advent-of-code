---
title: "Day 5"
author: "Dave"
format: html
editor: visual
---

## Libraries

```{r libs}
library(conflicted)
library(purrr)
library(stringr)
library(dplyr)
conflicted::conflicts_prefer(dplyr::lag)
conflicted::conflicts_prefer(dplyr::filter)
library(forcats)
library(here)
library(tidyr)
```

## Read data

```{r read_data}
maps <- readLines(here("inputs", "seed-maps.txt"))
```

## Format data

```{r format_data}
seeds <- maps[1]

maps <- maps[-1]

blanks <- maps == ""

maps_list <- as.list(maps[which(blanks) + 1])

names(maps_list) <- maps_list

maps_list

maps_list <- 
  map(maps_list,
      \(x){
        name_index <- which(maps == x)
        next_blank <- min(which(blanks)[which(blanks) > name_index])
        # browser()
        start <- name_index+1
        end <- min(next_blank - 1, length(maps))
        maps[start:end]
      })

maps <- maps_list
rm(maps_list)

names(maps) <- str_remove(names(maps), " map:")

maps <-
  map(maps,
      \(x){
        nums <- 
          str_split_fixed(x, " ", n = 3) |> 
          as.numeric()
        
        dim(nums) <- c(length(nums)/3 , 3)
        
        colnames(nums) <- c("destination_range_start",
                            "source_range_start", 
                            "range_length")
        
        as_tibble(nums)
      })

maps <- 
  imap(maps,
       \(tibble, list_name){
         mutate(tibble, map_type = list_name)
       })

maps <- bind_rows(maps)

maps <-
  relocate(maps, map_type) |> 
  mutate(map_type =
           ordered(map_type) |> 
           fct_inorder())
  

maps <- arrange(maps, map_type, source_range_start)
```

## Part 1: Find lowest location number

### Create ranges and functions

```{r create_ranges_and_functions}
maps <- 
  mutate(maps, 
         source_range_end = source_range_start + range_length - 1) |> 
  relocate(source_range_end, .after = source_range_start)

maps <- 
  group_by(maps, map_type) |> 
  mutate(last_range_ended = lag(source_range_end, default = -1),
         no_gap = source_range_start >= last_range_ended + 1)

head(maps)

summarise(maps,
          any_gaps = any(!no_gap),
          starts_zero = min(source_range_start) == 0)
```

Okay, there are no gaps in the source ranges and they all start at zero. So every value from zero to the maximum is explicitly defined in the source ranges. That means the stuff about 'lookup numbers that aren't mapped' is a bit of a red herring.

```{r drop_no_gaps}
maps <- select(maps, -no_gap, -last_range_ended)
maps <- ungroup(maps)
```

### Make lookup function

```{r lookup_function}

lookup <- function(source, source_range_start, destination_range_start){
  source + (destination_range_start - source_range_start)
}
```

### Try it out

```{r try_it_out}
seeds <- 
  str_remove(seeds, "seeds: ") |> 
  str_split_1(" ") |> 
  as.numeric()

test_seed <- seeds[1]

test_tibble <- filter(maps, map_type == "seed-to-soil")

filter(test_tibble,
       source_range_start <= test_seed,
       source_range_end >= test_seed) |> 
  mutate(source = test_seed) |> 
  select(source_range_start, destination_range_start, source) |> 
  pmap_dbl(lookup)
```

Nice! Now we just need to split our tibble into a list and make a nesting function that can `reduce()` our seed to a soil or something.

```{r nesting_function}

get_next_source <- function(last_source, this_tibble){

filtered_tibble <-
  filter(this_tibble, source_range_start <= last_source,
         source_range_end >= last_source)

if(nrow(filtered_tibble) == 0){
  
  out <- last_source
  
} else {
  
  out <-
    mutate(filtered_tibble, 
           source = last_source) |> 
    select(source_range_start, destination_range_start, source) |> 
    pmap_dbl(lookup)
  
}

# cat(out, "\n")

out

}

get_next_source(test_seed, test_tibble)

maps <- group_by(maps, map_type)
map_types <- group_keys(maps)
maps <- group_split(maps)
names(maps) <- map_types[["map_type"]]

names(maps)

reduce(maps, get_next_source, .init = test_seed)
```

Hooray! Now we can map our reducer to get all the location numbers and find the lowest location.

```{r get_all_locations}
locations <-
  map_dbl(
    seeds,
    \(x){
      reduce(maps, get_next_source, .init = x)
    }
  )

locations

min(locations)
```

## Part 2: Seeds are actually ranges

This seems kind of trivial ngl

```{r make_seed_ranges}
seeds
```

Oh no maybe not.

```{r get_ranges}
odd <- (1:length(seeds)) %% 2 == 1
seed_starts <- seeds[odd]
seed_ends   <- seeds[!odd]

seeds <- tibble(seed_starts, seed_ends)

seeds <- mutate(seeds, seeds_in_range = abs(seed_starts - seed_ends))
```

Hmmm...

Okay, the mapping is linear, which means that for a given source range the lowest input value will return the lowest output value. But higher source values could still yield lower destinations depending on how each range is mapped.

So, for each seed range, find the ranges of destination values that could be returned.

```{r find_ranges}
seeds <- mutate(seeds, 
                seed_starts_2 = pmin(seed_starts, seed_ends),
                seed_ends = pmax(seed_starts, seed_ends),
                seed_starts = seed_starts_2) |> 
  select(-seed_starts_2) |> 
  arrange(seed_starts) |> 
  mutate(seed_batch = row_number())

seeds <- mutate(seeds,
                overlaps = lag(seed_ends) > seed_starts)

seeds
```

Okay so it looks like there is actually only one continual range of seeds? The end of every range is larger than the beginning of the range with the next-highest start point. 

```{r seed_range}
seed_range <- c(min(seeds[["seed_starts"]]), max(seeds[["seed_ends"]]))
seed_range
```

And now we can drop all the rows of the tibble that fall outwith that range:

```{r drop_tibble_rows_outwith_range}
viable_source_ranges <- 
  test_tibble |> 
  filter(!(source_range_start > seed_range[2] | 
             source_range_end < seed_range[1])) |> 
  mutate(min_source = pmax(seed_range[1], source_range_start),
         max_source = pmin(seed_range[2], source_range_end))

min_destinations <-
  select(viable_source_ranges, 
         source_range_start, destination_range_start, 
         source = min_source) |> 
  pmap_dbl(lookup)

max_destinations <- 
  select(viable_source_ranges, 
         source_range_start, destination_range_start, 
         source = max_source) |> 
  pmap_dbl(lookup)

destinations <-
  cbind(min_destination = min_destinations, max_destination = max_destinations) |> 
  as_tibble() |> 
  arrange(min_destination)

destinations <- 
  mutate(
    destinations, 
    gap = lag(max_destination) == min_destination - 1,
    gap = replace_na(gap, TRUE),
    gapless_group = consecutive_id(gap)
  )

destinations <- 
  summarise(
    destinations,
    destination_range_start = min(min_destination),
    destination_range_end = max(max_destination), 
    .by = gapless_group
  ) |> 
  select(-gapless_group)

get_destinations <- function(destination_range_start, destination_range_end, map_tibble){
  
        drs <- destination_range_start
        dre <- destination_range_end
         
         viable_source_ranges <-
           
           map_tibble |>
           
           filter(!(source_range_start > drs |
                      source_range_end < dre)) |>
           
           mutate(min_source = pmax(drs, source_range_start),
                  max_source = pmin(dre, source_range_end))
         
         min_destinations <-
           select(viable_source_ranges,
                  source_range_start,
                  destination_range_start,
                  source = min_source) |>
           pmap_dbl(lookup)
         
         max_destinations <-
           select(viable_source_ranges,
                  source_range_start,
                  destination_range_start,
                  source = max_source) |>
           pmap_dbl(lookup)
         
         destinations <-
           cbind(min_destination = min_destinations, max_destination = max_destinations) |>
           as_tibble() |>
           arrange(min_destination)
         
         destinations <-
           mutate(
             destinations,
             gap = lag(max_destination) == min_destination - 1,
             gap = replace_na(gap, TRUE),
             gapless_group = consecutive_id(gap)
           )
         
         destinations <-
           summarise(
             destinations,
             destination_range_start = min(min_destination),
             destination_range_end = max(max_destination),
             .by = gapless_group
           ) |> 
           select(-gapless_group)
         
         destinations
       }

get_destination_ranges <- function(destinations, map_tibble){
  pmap(destinations, get_destinations, map_tibble = map_tibble) |> 
    bind_rows() |> 
    distinct()
}

get_destination_ranges(destinations, maps[[2]])


final_destinations <- reduce(maps[2:length(maps)], get_destination_ranges, .init = destinations)

min(final_destinations[["destination_range_start"]])
```

```{r idk}
# start <- seeds[["seed_starts"]][1]
# end   <- seeds[["seed_ends"]][1]
# 
# ends <- c(start, end)
# ends <- sort(ends)
# names(ends) <- c("start", "end")
# 
# viable_source_ranges <- 
#   test_tibble |> 
#   filter(!(source_range_start > ends[["end"]] | 
#              source_range_end < ends[["start"]])) |> 
#   mutate(min_source = pmax(ends[["start"]], source_range_start),
#          max_source = pmin(ends[["end"]], source_range_end)) 
# 

# 
# destinations
```

So that's every possible range of soils for the first range of seeds. We need to somehow map this across all seeds and then reduce again between steps to stop it sprawling out of control.

Perhaps we could just find the rows of the soils tibble that don't intersect the seeds tibble?

We could also simplify the ranges of seeds if we play it smart.

We can go backwards, I think. Look at the lowest possible destination range in the last tibble, work backwards from there to get an exhaustive map to the seed-soil table.

```{r go_backwards}
spam <- rev(maps)

spam <- map(spam, \(x) arrange(x, destination_range_start))
```

No I think we can just do a 'reduce()' type deal on the first code block I wrote. I'm thinking in circles.
